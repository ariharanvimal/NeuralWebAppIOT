{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, NgModule, EventEmitter, Injectable, Inject } from '@angular/core';\nimport * as i1 from 'mqtt-browser';\nimport { connect } from 'mqtt-browser';\nimport { BehaviorSubject, Subject, using, Subscription, merge, Observable } from 'rxjs';\nimport { publishReplay, publish, filter, refCount } from 'rxjs/operators';\nvar MqttConnectionState;\n(function (MqttConnectionState) {\n  MqttConnectionState[MqttConnectionState[\"CLOSED\"] = 0] = \"CLOSED\";\n  MqttConnectionState[MqttConnectionState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  MqttConnectionState[MqttConnectionState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(MqttConnectionState || (MqttConnectionState = {}));\nconst MQTT_SERVICE_OPTIONS = {\n  connectOnCreate: true,\n  hostname: 'localhost',\n  port: 1884,\n  path: ''\n};\nconst MqttServiceConfig = new InjectionToken('NgxMqttServiceConfig');\nconst MqttClientService = new InjectionToken('NgxMqttClientService');\nclass MqttModule {\n  static forRoot(config, client) {\n    return {\n      ngModule: MqttModule,\n      providers: [{\n        provide: MqttServiceConfig,\n        useValue: config\n      }, {\n        provide: MqttClientService,\n        useValue: client\n      }]\n    };\n  }\n  static #_ = this.ɵfac = function MqttModule_Factory(t) {\n    return new (t || MqttModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MqttModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MqttModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n// A javascript function that takes two objects and merges them recursively\nfunction mergeDeep(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n}\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\nclass MqttService {\n  /**\n   * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n   * options to configure behavior of this service, like if the connection to the broker\n   * should be established on creation of this service or not.\n   */\n  constructor(options, client) {\n    this.options = options;\n    /** a map of all mqtt observables by filter */\n    this.observables = {};\n    /** the connection state */\n    this.state = new BehaviorSubject(MqttConnectionState.CLOSED);\n    /** an observable of the last mqtt message */\n    this.messages = new Subject();\n    this._clientId = this._generateClientId();\n    this._connectTimeout = 10000;\n    this._reconnectPeriod = 10000;\n    this._onConnect = new EventEmitter();\n    this._onReconnect = new EventEmitter();\n    this._onClose = new EventEmitter();\n    this._onOffline = new EventEmitter();\n    this._onError = new EventEmitter();\n    this._onEnd = new EventEmitter();\n    this._onMessage = new EventEmitter();\n    this._onSuback = new EventEmitter();\n    this._onPacketsend = new EventEmitter();\n    this._onPacketreceive = new EventEmitter();\n    this._handleOnConnect = e => {\n      if (this.options.connectOnCreate === true) {\n        Object.keys(this.observables).forEach(filterString => {\n          this.client.subscribe(filterString);\n        });\n      }\n      this.state.next(MqttConnectionState.CONNECTED);\n      this._onConnect.emit(e);\n    };\n    this._handleOnReconnect = () => {\n      if (this.options.connectOnCreate === true) {\n        Object.keys(this.observables).forEach(filterString => {\n          this.client.subscribe(filterString);\n        });\n      }\n      this.state.next(MqttConnectionState.CONNECTING);\n      this._onReconnect.emit();\n    };\n    this._handleOnClose = () => {\n      this.state.next(MqttConnectionState.CLOSED);\n      this._onClose.emit();\n    };\n    this._handleOnOffline = () => {\n      this._onOffline.emit();\n    };\n    this._handleOnError = e => {\n      this._onError.emit(e);\n      console.error(e);\n    };\n    this._handleOnEnd = () => {\n      this._onEnd.emit();\n    };\n    this._handleOnMessage = (topic, payload, packet) => {\n      this._onMessage.emit(packet);\n      if (packet.cmd === 'publish') {\n        this.messages.next(packet);\n      }\n    };\n    this._handleOnPacketsend = e => {\n      this._onPacketsend.emit(e);\n    };\n    this._handleOnPacketreceive = e => {\n      this._onPacketreceive.emit(e);\n    };\n    if (options.connectOnCreate !== false) {\n      this.connect({}, client);\n    }\n    this.state.subscribe();\n  }\n  /**\n   * gets the _clientId\n   */\n  get clientId() {\n    return this._clientId;\n  }\n  /** An EventEmitter to listen to connect messages */\n  get onConnect() {\n    return this._onConnect;\n  }\n  /** An EventEmitter to listen to reconnect messages */\n  get onReconnect() {\n    return this._onReconnect;\n  }\n  /** An EventEmitter to listen to close messages */\n  get onClose() {\n    return this._onClose;\n  }\n  /** An EventEmitter to listen to offline events */\n  get onOffline() {\n    return this._onOffline;\n  }\n  /** An EventEmitter to listen to error events */\n  get onError() {\n    return this._onError;\n  }\n  /** An EventEmitter to listen to close messages */\n  get onEnd() {\n    return this._onEnd;\n  }\n  /** An EventEmitter to listen to message events */\n  get onMessage() {\n    return this._onMessage;\n  }\n  /** An EventEmitter to listen to packetsend messages */\n  get onPacketsend() {\n    return this._onPacketsend;\n  }\n  /** An EventEmitter to listen to packetreceive messages */\n  get onPacketreceive() {\n    return this._onPacketreceive;\n  }\n  /** An EventEmitter to listen to suback events */\n  get onSuback() {\n    return this._onSuback;\n  }\n  /**\n   * This static method shall be used to determine whether a MQTT\n   * topic matches a given filter. The matching rules are specified in the MQTT\n   * standard documentation and in the library test suite.\n   *\n   * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n   * @param  {string}  topic  A topic may not contain wildcards.\n   * @return {boolean}        true on match and false otherwise.\n   */\n  static filterMatchesTopic(filterString, topic) {\n    if (filterString[0] === '#' && topic[0] === '$') {\n      return false;\n    }\n    // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n    const fs = (filterString || '').split('/').reverse();\n    const ts = (topic || '').split('/').reverse();\n    // This function is tail recursive and compares both arrays one element at a time.\n    const match = () => {\n      // Cutting of the last element of both the filter and the topic using pop().\n      const f = fs.pop();\n      const t = ts.pop();\n      switch (f) {\n        // In case the filter level is '#', this is a match no matter whether\n        // the topic is undefined on this level or not ('#' matches parent element as well!).\n        case '#':\n          return true;\n        // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n        case '+':\n          return t ? match() : false;\n        // In all other cases the filter level must match the topic level,\n        // both must be defined and the filter tail must match the topic\n        // tail (which is determined by the recursive call of match()).\n        default:\n          return f === t && (f === undefined ? true : match());\n      }\n    };\n    return match();\n  }\n  /**\n   * connect manually connects to the mqtt broker.\n   */\n  connect(opts, client) {\n    const options = mergeDeep(this.options || {}, opts);\n    const protocol = options.protocol || 'ws';\n    const hostname = options.hostname || 'localhost';\n    if (options.url) {\n      this._url = options.url;\n    } else {\n      this._url = `${protocol}://${hostname}`;\n      this._url += options.port ? `:${options.port}` : '';\n      this._url += options.path ? `${options.path}` : '';\n    }\n    this.state.next(MqttConnectionState.CONNECTING);\n    const mergedOptions = mergeDeep({\n      clientId: this._clientId,\n      reconnectPeriod: this._reconnectPeriod,\n      connectTimeout: this._connectTimeout\n    }, options);\n    if (this.client) {\n      this.client.end(true);\n    }\n    if (!client) {\n      this.client = connect(this._url, mergedOptions);\n    } else {\n      this.client = client;\n    }\n    this._clientId = mergedOptions.clientId;\n    this.client.on('connect', this._handleOnConnect);\n    this.client.on('reconnect', this._handleOnReconnect);\n    this.client.on('close', this._handleOnClose);\n    this.client.on('offline', this._handleOnOffline);\n    this.client.on('error', this._handleOnError);\n    this.client.stream.on('error', this._handleOnError);\n    this.client.on('end', this._handleOnEnd);\n    this.client.on('message', this._handleOnMessage);\n    this.client.on('packetsend', this._handleOnPacketsend);\n    this.client.on('packetreceive', this._handleOnPacketreceive);\n  }\n  /**\n   * disconnect disconnects from the mqtt client.\n   * This method `should` be executed when leaving the application.\n   */\n  disconnect(force = true) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.end(force);\n  }\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Every new subscriber gets the latest message.\n   */\n  observeRetained(filterString, opts = {\n    qos: 1\n  }) {\n    return this._generalObserve(filterString, () => publishReplay(1), opts);\n  }\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   */\n  observe(filterString, opts = {\n    qos: 1\n  }) {\n    return this._generalObserve(filterString, () => publish(), opts);\n  }\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Depending on the publish function, the messages will either be replayed after new\n   * subscribers subscribe or the messages are just passed through\n   */\n  _generalObserve(filterString, publishFn, opts) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    if (!this.observables[filterString]) {\n      const rejected = new Subject();\n      this.observables[filterString] = using(\n      // resourceFactory: Do the actual ref-counting MQTT subscription.\n      // refcount is decreased on unsubscribe.\n      () => {\n        const subscription = new Subscription();\n        this.client.subscribe(filterString, opts, (err, granted) => {\n          if (granted) {\n            // granted can be undefined when an error occurs when the client is disconnecting\n            granted.forEach(granted_ => {\n              if (granted_.qos === 128) {\n                delete this.observables[granted_.topic];\n                this.client.unsubscribe(granted_.topic);\n                rejected.error(`subscription for '${granted_.topic}' rejected!`);\n              }\n              this._onSuback.emit({\n                filter: filterString,\n                granted: granted_.qos !== 128\n              });\n            });\n          }\n        });\n        subscription.add(() => {\n          delete this.observables[filterString];\n          this.client.unsubscribe(filterString);\n        });\n        return subscription;\n      },\n      // observableFactory: Create the observable that is consumed from.\n      // This part is not executed until the Observable returned by\n      // `observe` gets actually subscribed.\n      subscription => merge(rejected, this.messages)).pipe(filter(msg => MqttService.filterMatchesTopic(filterString, msg.topic)), publishFn(), refCount());\n    }\n    return this.observables[filterString];\n  }\n  /**\n   * This method returns an observable for a topic with optional options.\n   * After subscribing, the actual mqtt publication will be executed and\n   * the observable will emit an empty value and completes, if publishing was successful\n   * or throws an error, if the publication fails.\n   */\n  publish(topic, message, options = {}) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    return Observable.create(obs => {\n      this.client.publish(topic, message, options, error => {\n        if (error) {\n          obs.error(error);\n        } else {\n          obs.next();\n          obs.complete();\n        }\n      });\n    });\n  }\n  /**\n   * This method publishes a message for a topic with optional options.\n   * If an error occurs, it will throw.\n   */\n  unsafePublish(topic, message, options = {}) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.publish(topic, message, options, error => {\n      if (error) {\n        throw error;\n      }\n    });\n  }\n  _generateClientId() {\n    return 'client-' + Math.random().toString(36).substr(2, 19);\n  }\n  static #_ = this.ɵfac = function MqttService_Factory(t) {\n    return new (t || MqttService)(i0.ɵɵinject(MqttServiceConfig), i0.ɵɵinject(MqttClientService));\n  };\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MqttService,\n    factory: MqttService.ɵfac,\n    providedIn: 'root'\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MqttService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MqttServiceConfig]\n      }]\n    }, {\n      type: i1.MqttClient,\n      decorators: [{\n        type: Inject,\n        args: [MqttClientService]\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * Public API Surface of ngx-mqtt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MQTT_SERVICE_OPTIONS, MqttClientService, MqttConnectionState, MqttModule, MqttService, MqttServiceConfig };","map":{"version":3,"names":["i0","InjectionToken","NgModule","EventEmitter","Injectable","Inject","i1","connect","BehaviorSubject","Subject","using","Subscription","merge","Observable","publishReplay","publish","filter","refCount","MqttConnectionState","MQTT_SERVICE_OPTIONS","connectOnCreate","hostname","port","path","MqttServiceConfig","MqttClientService","MqttModule","forRoot","config","client","ngModule","providers","provide","useValue","ɵfac","ɵmod","ɵinj","type","mergeDeep","target","sources","length","source","shift","isObject","key","Object","assign","item","Array","isArray","MqttService","constructor","options","observables","state","CLOSED","messages","_clientId","_generateClientId","_connectTimeout","_reconnectPeriod","_onConnect","_onReconnect","_onClose","_onOffline","_onError","_onEnd","_onMessage","_onSuback","_onPacketsend","_onPacketreceive","_handleOnConnect","e","keys","forEach","filterString","subscribe","next","CONNECTED","emit","_handleOnReconnect","CONNECTING","_handleOnClose","_handleOnOffline","_handleOnError","console","error","_handleOnEnd","_handleOnMessage","topic","payload","packet","cmd","_handleOnPacketsend","_handleOnPacketreceive","clientId","onConnect","onReconnect","onClose","onOffline","onError","onEnd","onMessage","onPacketsend","onPacketreceive","onSuback","filterMatchesTopic","fs","split","reverse","ts","match","f","pop","t","undefined","opts","protocol","url","_url","mergedOptions","reconnectPeriod","connectTimeout","end","on","stream","disconnect","force","Error","observeRetained","qos","_generalObserve","observe","publishFn","rejected","subscription","err","granted","granted_","unsubscribe","add","pipe","msg","message","create","obs","complete","unsafePublish","Math","random","toString","substr","ɵprov","args","providedIn","decorators","MqttClient"],"sources":["C:/Users/Ariharan/Desktop/NeuralWebAppIOT/WebIOTApplication/UI/NeuralIOT/node_modules/ngx-mqtt/fesm2022/ngx-mqtt.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, NgModule, EventEmitter, Injectable, Inject } from '@angular/core';\nimport * as i1 from 'mqtt-browser';\nimport { connect } from 'mqtt-browser';\nimport { BehaviorSubject, Subject, using, Subscription, merge, Observable } from 'rxjs';\nimport { publishReplay, publish, filter, refCount } from 'rxjs/operators';\n\nvar MqttConnectionState;\n(function (MqttConnectionState) {\n    MqttConnectionState[MqttConnectionState[\"CLOSED\"] = 0] = \"CLOSED\";\n    MqttConnectionState[MqttConnectionState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    MqttConnectionState[MqttConnectionState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(MqttConnectionState || (MqttConnectionState = {}));\n\nconst MQTT_SERVICE_OPTIONS = {\n    connectOnCreate: true,\n    hostname: 'localhost',\n    port: 1884,\n    path: ''\n};\nconst MqttServiceConfig = new InjectionToken('NgxMqttServiceConfig');\nconst MqttClientService = new InjectionToken('NgxMqttClientService');\nclass MqttModule {\n    static forRoot(config, client) {\n        return {\n            ngModule: MqttModule,\n            providers: [\n                {\n                    provide: MqttServiceConfig,\n                    useValue: config\n                },\n                {\n                    provide: MqttClientService,\n                    useValue: client\n                }\n            ]\n        };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttModule }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttModule, decorators: [{\n            type: NgModule\n        }] });\n\n// A javascript function that takes two objects and merges them recursively\nfunction mergeDeep(target, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                mergeDeep(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    return mergeDeep(target, ...sources);\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\nclass MqttService {\n    /**\n     * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n     * options to configure behavior of this service, like if the connection to the broker\n     * should be established on creation of this service or not.\n     */\n    constructor(options, client) {\n        this.options = options;\n        /** a map of all mqtt observables by filter */\n        this.observables = {};\n        /** the connection state */\n        this.state = new BehaviorSubject(MqttConnectionState.CLOSED);\n        /** an observable of the last mqtt message */\n        this.messages = new Subject();\n        this._clientId = this._generateClientId();\n        this._connectTimeout = 10000;\n        this._reconnectPeriod = 10000;\n        this._onConnect = new EventEmitter();\n        this._onReconnect = new EventEmitter();\n        this._onClose = new EventEmitter();\n        this._onOffline = new EventEmitter();\n        this._onError = new EventEmitter();\n        this._onEnd = new EventEmitter();\n        this._onMessage = new EventEmitter();\n        this._onSuback = new EventEmitter();\n        this._onPacketsend = new EventEmitter();\n        this._onPacketreceive = new EventEmitter();\n        this._handleOnConnect = (e) => {\n            if (this.options.connectOnCreate === true) {\n                Object.keys(this.observables).forEach((filterString) => {\n                    this.client.subscribe(filterString);\n                });\n            }\n            this.state.next(MqttConnectionState.CONNECTED);\n            this._onConnect.emit(e);\n        };\n        this._handleOnReconnect = () => {\n            if (this.options.connectOnCreate === true) {\n                Object.keys(this.observables).forEach((filterString) => {\n                    this.client.subscribe(filterString);\n                });\n            }\n            this.state.next(MqttConnectionState.CONNECTING);\n            this._onReconnect.emit();\n        };\n        this._handleOnClose = () => {\n            this.state.next(MqttConnectionState.CLOSED);\n            this._onClose.emit();\n        };\n        this._handleOnOffline = () => {\n            this._onOffline.emit();\n        };\n        this._handleOnError = (e) => {\n            this._onError.emit(e);\n            console.error(e);\n        };\n        this._handleOnEnd = () => {\n            this._onEnd.emit();\n        };\n        this._handleOnMessage = (topic, payload, packet) => {\n            this._onMessage.emit(packet);\n            if (packet.cmd === 'publish') {\n                this.messages.next(packet);\n            }\n        };\n        this._handleOnPacketsend = (e) => {\n            this._onPacketsend.emit(e);\n        };\n        this._handleOnPacketreceive = (e) => {\n            this._onPacketreceive.emit(e);\n        };\n        if (options.connectOnCreate !== false) {\n            this.connect({}, client);\n        }\n        this.state.subscribe();\n    }\n    /**\n     * gets the _clientId\n     */\n    get clientId() {\n        return this._clientId;\n    }\n    /** An EventEmitter to listen to connect messages */\n    get onConnect() {\n        return this._onConnect;\n    }\n    /** An EventEmitter to listen to reconnect messages */\n    get onReconnect() {\n        return this._onReconnect;\n    }\n    /** An EventEmitter to listen to close messages */\n    get onClose() {\n        return this._onClose;\n    }\n    /** An EventEmitter to listen to offline events */\n    get onOffline() {\n        return this._onOffline;\n    }\n    /** An EventEmitter to listen to error events */\n    get onError() {\n        return this._onError;\n    }\n    /** An EventEmitter to listen to close messages */\n    get onEnd() {\n        return this._onEnd;\n    }\n    /** An EventEmitter to listen to message events */\n    get onMessage() {\n        return this._onMessage;\n    }\n    /** An EventEmitter to listen to packetsend messages */\n    get onPacketsend() {\n        return this._onPacketsend;\n    }\n    /** An EventEmitter to listen to packetreceive messages */\n    get onPacketreceive() {\n        return this._onPacketreceive;\n    }\n    /** An EventEmitter to listen to suback events */\n    get onSuback() {\n        return this._onSuback;\n    }\n    /**\n     * This static method shall be used to determine whether a MQTT\n     * topic matches a given filter. The matching rules are specified in the MQTT\n     * standard documentation and in the library test suite.\n     *\n     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n     * @param  {string}  topic  A topic may not contain wildcards.\n     * @return {boolean}        true on match and false otherwise.\n     */\n    static filterMatchesTopic(filterString, topic) {\n        if (filterString[0] === '#' && topic[0] === '$') {\n            return false;\n        }\n        // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n        const fs = (filterString || '').split('/').reverse();\n        const ts = (topic || '').split('/').reverse();\n        // This function is tail recursive and compares both arrays one element at a time.\n        const match = () => {\n            // Cutting of the last element of both the filter and the topic using pop().\n            const f = fs.pop();\n            const t = ts.pop();\n            switch (f) {\n                // In case the filter level is '#', this is a match no matter whether\n                // the topic is undefined on this level or not ('#' matches parent element as well!).\n                case '#':\n                    return true;\n                // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n                case '+':\n                    return t ? match() : false;\n                // In all other cases the filter level must match the topic level,\n                // both must be defined and the filter tail must match the topic\n                // tail (which is determined by the recursive call of match()).\n                default:\n                    return f === t && (f === undefined ? true : match());\n            }\n        };\n        return match();\n    }\n    /**\n     * connect manually connects to the mqtt broker.\n     */\n    connect(opts, client) {\n        const options = mergeDeep(this.options || {}, opts);\n        const protocol = options.protocol || 'ws';\n        const hostname = options.hostname || 'localhost';\n        if (options.url) {\n            this._url = options.url;\n        }\n        else {\n            this._url = `${protocol}://${hostname}`;\n            this._url += options.port ? `:${options.port}` : '';\n            this._url += options.path ? `${options.path}` : '';\n        }\n        this.state.next(MqttConnectionState.CONNECTING);\n        const mergedOptions = mergeDeep({\n            clientId: this._clientId,\n            reconnectPeriod: this._reconnectPeriod,\n            connectTimeout: this._connectTimeout\n        }, options);\n        if (this.client) {\n            this.client.end(true);\n        }\n        if (!client) {\n            this.client = connect(this._url, mergedOptions);\n        }\n        else {\n            this.client = client;\n        }\n        this._clientId = mergedOptions.clientId;\n        this.client.on('connect', this._handleOnConnect);\n        this.client.on('reconnect', this._handleOnReconnect);\n        this.client.on('close', this._handleOnClose);\n        this.client.on('offline', this._handleOnOffline);\n        this.client.on('error', this._handleOnError);\n        this.client.stream.on('error', this._handleOnError);\n        this.client.on('end', this._handleOnEnd);\n        this.client.on('message', this._handleOnMessage);\n        this.client.on('packetsend', this._handleOnPacketsend);\n        this.client.on('packetreceive', this._handleOnPacketreceive);\n    }\n    /**\n     * disconnect disconnects from the mqtt client.\n     * This method `should` be executed when leaving the application.\n     */\n    disconnect(force = true) {\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        this.client.end(force);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Every new subscriber gets the latest message.\n     */\n    observeRetained(filterString, opts = { qos: 1 }) {\n        return this._generalObserve(filterString, () => publishReplay(1), opts);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     */\n    observe(filterString, opts = { qos: 1 }) {\n        return this._generalObserve(filterString, () => publish(), opts);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Depending on the publish function, the messages will either be replayed after new\n     * subscribers subscribe or the messages are just passed through\n     */\n    _generalObserve(filterString, publishFn, opts) {\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        if (!this.observables[filterString]) {\n            const rejected = new Subject();\n            this.observables[filterString] = using(\n            // resourceFactory: Do the actual ref-counting MQTT subscription.\n            // refcount is decreased on unsubscribe.\n            () => {\n                const subscription = new Subscription();\n                this.client.subscribe(filterString, opts, (err, granted) => {\n                    if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\n                        granted.forEach((granted_) => {\n                            if (granted_.qos === 128) {\n                                delete this.observables[granted_.topic];\n                                this.client.unsubscribe(granted_.topic);\n                                rejected.error(`subscription for '${granted_.topic}' rejected!`);\n                            }\n                            this._onSuback.emit({ filter: filterString, granted: granted_.qos !== 128 });\n                        });\n                    }\n                });\n                subscription.add(() => {\n                    delete this.observables[filterString];\n                    this.client.unsubscribe(filterString);\n                });\n                return subscription;\n            }, \n            // observableFactory: Create the observable that is consumed from.\n            // This part is not executed until the Observable returned by\n            // `observe` gets actually subscribed.\n            (subscription) => merge(rejected, this.messages))\n                .pipe(filter((msg) => MqttService.filterMatchesTopic(filterString, msg.topic)), publishFn(), refCount());\n        }\n        return this.observables[filterString];\n    }\n    /**\n     * This method returns an observable for a topic with optional options.\n     * After subscribing, the actual mqtt publication will be executed and\n     * the observable will emit an empty value and completes, if publishing was successful\n     * or throws an error, if the publication fails.\n     */\n    publish(topic, message, options = {}) {\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        return Observable.create((obs) => {\n            this.client.publish(topic, message, options, (error) => {\n                if (error) {\n                    obs.error(error);\n                }\n                else {\n                    obs.next();\n                    obs.complete();\n                }\n            });\n        });\n    }\n    /**\n     * This method publishes a message for a topic with optional options.\n     * If an error occurs, it will throw.\n     */\n    unsafePublish(topic, message, options = {}) {\n        if (!this.client) {\n            throw new Error('mqtt client not connected');\n        }\n        this.client.publish(topic, message, options, (error) => {\n            if (error) {\n                throw (error);\n            }\n        });\n    }\n    _generateClientId() {\n        return 'client-' + Math.random().toString(36).substr(2, 19);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttService, deps: [{ token: MqttServiceConfig }, { token: MqttClientService }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttService, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.3\", ngImport: i0, type: MqttService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MqttServiceConfig]\n                }] }, { type: i1.MqttClient, decorators: [{\n                    type: Inject,\n                    args: [MqttClientService]\n                }] }]; } });\n\n/*\n * Public API Surface of ngx-mqtt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MQTT_SERVICE_OPTIONS, MqttClientService, MqttConnectionState, MqttModule, MqttService, MqttServiceConfig };\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,cAAc,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,UAAU,EAAEC,MAAM,QAAQ,eAAe;AAC1F,OAAO,KAAKC,EAAE,MAAM,cAAc;AAClC,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,eAAe,EAAEC,OAAO,EAAEC,KAAK,EAAEC,YAAY,EAAEC,KAAK,EAAEC,UAAU,QAAQ,MAAM;AACvF,SAASC,aAAa,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,gBAAgB;AAEzE,IAAIC,mBAAmB;AACvB,CAAC,UAAUA,mBAAmB,EAAE;EAC5BA,mBAAmB,CAACA,mBAAmB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;EACjEA,mBAAmB,CAACA,mBAAmB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;EACzEA,mBAAmB,CAACA,mBAAmB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;AAC3E,CAAC,EAAEA,mBAAmB,KAAKA,mBAAmB,GAAG,CAAC,CAAC,CAAC,CAAC;AAErD,MAAMC,oBAAoB,GAAG;EACzBC,eAAe,EAAE,IAAI;EACrBC,QAAQ,EAAE,WAAW;EACrBC,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE;AACV,CAAC;AACD,MAAMC,iBAAiB,GAAG,IAAIvB,cAAc,CAAC,sBAAsB,CAAC;AACpE,MAAMwB,iBAAiB,GAAG,IAAIxB,cAAc,CAAC,sBAAsB,CAAC;AACpE,MAAMyB,UAAU,CAAC;EACb,OAAOC,OAAO,CAACC,MAAM,EAAEC,MAAM,EAAE;IAC3B,OAAO;MACHC,QAAQ,EAAEJ,UAAU;MACpBK,SAAS,EAAE,CACP;QACIC,OAAO,EAAER,iBAAiB;QAC1BS,QAAQ,EAAEL;MACd,CAAC,EACD;QACII,OAAO,EAAEP,iBAAiB;QAC1BQ,QAAQ,EAAEJ;MACd,CAAC;IAET,CAAC;EACL;EAAC,YACQ,IAAI,CAACK,IAAI;IAAA,iBAAwFR,UAAU;EAAA,CAAkD;EAAA,aAC7J,IAAI,CAACS,IAAI,kBAD8EnC,EAAE;IAAA,MACS0B;EAAU,EAAG;EAAA,aAC/G,IAAI,CAACU,IAAI,kBAF8EpC,EAAE,qBAEsB;AAC5H;AACA;EAAA,mDAJoGA,EAAE,mBAIX0B,UAAU,EAAc,CAAC;IACxGW,IAAI,EAAEnC;EACV,CAAC,CAAC;AAAA;;AAEV;AACA,SAASoC,SAAS,CAACC,MAAM,EAAE,GAAGC,OAAO,EAAE;EACnC,IAAI,CAACA,OAAO,CAACC,MAAM,EAAE;IACjB,OAAOF,MAAM;EACjB;EACA,MAAMG,MAAM,GAAGF,OAAO,CAACG,KAAK,EAAE;EAC9B,IAAIC,QAAQ,CAACL,MAAM,CAAC,IAAIK,QAAQ,CAACF,MAAM,CAAC,EAAE;IACtC,KAAK,MAAMG,GAAG,IAAIH,MAAM,EAAE;MACtB,IAAIE,QAAQ,CAACF,MAAM,CAACG,GAAG,CAAC,CAAC,EAAE;QACvB,IAAI,CAACN,MAAM,CAACM,GAAG,CAAC,EAAE;UACdC,MAAM,CAACC,MAAM,CAACR,MAAM,EAAE;YAAE,CAACM,GAAG,GAAG,CAAC;UAAE,CAAC,CAAC;QACxC;QACAP,SAAS,CAACC,MAAM,CAACM,GAAG,CAAC,EAAEH,MAAM,CAACG,GAAG,CAAC,CAAC;MACvC,CAAC,MACI;QACDC,MAAM,CAACC,MAAM,CAACR,MAAM,EAAE;UAAE,CAACM,GAAG,GAAGH,MAAM,CAACG,GAAG;QAAE,CAAC,CAAC;MACjD;IACJ;EACJ;EACA,OAAOP,SAAS,CAACC,MAAM,EAAE,GAAGC,OAAO,CAAC;AACxC;AACA,SAASI,QAAQ,CAACI,IAAI,EAAE;EACpB,OAAOA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,WAAW,CAAC;EACd;AACJ;AACA;AACA;AACA;EACIC,WAAW,CAACC,OAAO,EAAExB,MAAM,EAAE;IACzB,IAAI,CAACwB,OAAO,GAAGA,OAAO;IACtB;IACA,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;IACrB;IACA,IAAI,CAACC,KAAK,GAAG,IAAI/C,eAAe,CAACU,mBAAmB,CAACsC,MAAM,CAAC;IAC5D;IACA,IAAI,CAACC,QAAQ,GAAG,IAAIhD,OAAO,EAAE;IAC7B,IAAI,CAACiD,SAAS,GAAG,IAAI,CAACC,iBAAiB,EAAE;IACzC,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,UAAU,GAAG,IAAI3D,YAAY,EAAE;IACpC,IAAI,CAAC4D,YAAY,GAAG,IAAI5D,YAAY,EAAE;IACtC,IAAI,CAAC6D,QAAQ,GAAG,IAAI7D,YAAY,EAAE;IAClC,IAAI,CAAC8D,UAAU,GAAG,IAAI9D,YAAY,EAAE;IACpC,IAAI,CAAC+D,QAAQ,GAAG,IAAI/D,YAAY,EAAE;IAClC,IAAI,CAACgE,MAAM,GAAG,IAAIhE,YAAY,EAAE;IAChC,IAAI,CAACiE,UAAU,GAAG,IAAIjE,YAAY,EAAE;IACpC,IAAI,CAACkE,SAAS,GAAG,IAAIlE,YAAY,EAAE;IACnC,IAAI,CAACmE,aAAa,GAAG,IAAInE,YAAY,EAAE;IACvC,IAAI,CAACoE,gBAAgB,GAAG,IAAIpE,YAAY,EAAE;IAC1C,IAAI,CAACqE,gBAAgB,GAAIC,CAAC,IAAK;MAC3B,IAAI,IAAI,CAACpB,OAAO,CAACjC,eAAe,KAAK,IAAI,EAAE;QACvC0B,MAAM,CAAC4B,IAAI,CAAC,IAAI,CAACpB,WAAW,CAAC,CAACqB,OAAO,CAAEC,YAAY,IAAK;UACpD,IAAI,CAAC/C,MAAM,CAACgD,SAAS,CAACD,YAAY,CAAC;QACvC,CAAC,CAAC;MACN;MACA,IAAI,CAACrB,KAAK,CAACuB,IAAI,CAAC5D,mBAAmB,CAAC6D,SAAS,CAAC;MAC9C,IAAI,CAACjB,UAAU,CAACkB,IAAI,CAACP,CAAC,CAAC;IAC3B,CAAC;IACD,IAAI,CAACQ,kBAAkB,GAAG,MAAM;MAC5B,IAAI,IAAI,CAAC5B,OAAO,CAACjC,eAAe,KAAK,IAAI,EAAE;QACvC0B,MAAM,CAAC4B,IAAI,CAAC,IAAI,CAACpB,WAAW,CAAC,CAACqB,OAAO,CAAEC,YAAY,IAAK;UACpD,IAAI,CAAC/C,MAAM,CAACgD,SAAS,CAACD,YAAY,CAAC;QACvC,CAAC,CAAC;MACN;MACA,IAAI,CAACrB,KAAK,CAACuB,IAAI,CAAC5D,mBAAmB,CAACgE,UAAU,CAAC;MAC/C,IAAI,CAACnB,YAAY,CAACiB,IAAI,EAAE;IAC5B,CAAC;IACD,IAAI,CAACG,cAAc,GAAG,MAAM;MACxB,IAAI,CAAC5B,KAAK,CAACuB,IAAI,CAAC5D,mBAAmB,CAACsC,MAAM,CAAC;MAC3C,IAAI,CAACQ,QAAQ,CAACgB,IAAI,EAAE;IACxB,CAAC;IACD,IAAI,CAACI,gBAAgB,GAAG,MAAM;MAC1B,IAAI,CAACnB,UAAU,CAACe,IAAI,EAAE;IAC1B,CAAC;IACD,IAAI,CAACK,cAAc,GAAIZ,CAAC,IAAK;MACzB,IAAI,CAACP,QAAQ,CAACc,IAAI,CAACP,CAAC,CAAC;MACrBa,OAAO,CAACC,KAAK,CAACd,CAAC,CAAC;IACpB,CAAC;IACD,IAAI,CAACe,YAAY,GAAG,MAAM;MACtB,IAAI,CAACrB,MAAM,CAACa,IAAI,EAAE;IACtB,CAAC;IACD,IAAI,CAACS,gBAAgB,GAAG,CAACC,KAAK,EAAEC,OAAO,EAAEC,MAAM,KAAK;MAChD,IAAI,CAACxB,UAAU,CAACY,IAAI,CAACY,MAAM,CAAC;MAC5B,IAAIA,MAAM,CAACC,GAAG,KAAK,SAAS,EAAE;QAC1B,IAAI,CAACpC,QAAQ,CAACqB,IAAI,CAACc,MAAM,CAAC;MAC9B;IACJ,CAAC;IACD,IAAI,CAACE,mBAAmB,GAAIrB,CAAC,IAAK;MAC9B,IAAI,CAACH,aAAa,CAACU,IAAI,CAACP,CAAC,CAAC;IAC9B,CAAC;IACD,IAAI,CAACsB,sBAAsB,GAAItB,CAAC,IAAK;MACjC,IAAI,CAACF,gBAAgB,CAACS,IAAI,CAACP,CAAC,CAAC;IACjC,CAAC;IACD,IAAIpB,OAAO,CAACjC,eAAe,KAAK,KAAK,EAAE;MACnC,IAAI,CAACb,OAAO,CAAC,CAAC,CAAC,EAAEsB,MAAM,CAAC;IAC5B;IACA,IAAI,CAAC0B,KAAK,CAACsB,SAAS,EAAE;EAC1B;EACA;AACJ;AACA;EACI,IAAImB,QAAQ,GAAG;IACX,OAAO,IAAI,CAACtC,SAAS;EACzB;EACA;EACA,IAAIuC,SAAS,GAAG;IACZ,OAAO,IAAI,CAACnC,UAAU;EAC1B;EACA;EACA,IAAIoC,WAAW,GAAG;IACd,OAAO,IAAI,CAACnC,YAAY;EAC5B;EACA;EACA,IAAIoC,OAAO,GAAG;IACV,OAAO,IAAI,CAACnC,QAAQ;EACxB;EACA;EACA,IAAIoC,SAAS,GAAG;IACZ,OAAO,IAAI,CAACnC,UAAU;EAC1B;EACA;EACA,IAAIoC,OAAO,GAAG;IACV,OAAO,IAAI,CAACnC,QAAQ;EACxB;EACA;EACA,IAAIoC,KAAK,GAAG;IACR,OAAO,IAAI,CAACnC,MAAM;EACtB;EACA;EACA,IAAIoC,SAAS,GAAG;IACZ,OAAO,IAAI,CAACnC,UAAU;EAC1B;EACA;EACA,IAAIoC,YAAY,GAAG;IACf,OAAO,IAAI,CAAClC,aAAa;EAC7B;EACA;EACA,IAAImC,eAAe,GAAG;IAClB,OAAO,IAAI,CAAClC,gBAAgB;EAChC;EACA;EACA,IAAImC,QAAQ,GAAG;IACX,OAAO,IAAI,CAACrC,SAAS;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOsC,kBAAkB,CAAC/B,YAAY,EAAEc,KAAK,EAAE;IAC3C,IAAId,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIc,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAC7C,OAAO,KAAK;IAChB;IACA;IACA,MAAMkB,EAAE,GAAG,CAAChC,YAAY,IAAI,EAAE,EAAEiC,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,EAAE;IACpD,MAAMC,EAAE,GAAG,CAACrB,KAAK,IAAI,EAAE,EAAEmB,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,EAAE;IAC7C;IACA,MAAME,KAAK,GAAG,MAAM;MAChB;MACA,MAAMC,CAAC,GAAGL,EAAE,CAACM,GAAG,EAAE;MAClB,MAAMC,CAAC,GAAGJ,EAAE,CAACG,GAAG,EAAE;MAClB,QAAQD,CAAC;QACL;QACA;QACA,KAAK,GAAG;UACJ,OAAO,IAAI;QACf;QACA,KAAK,GAAG;UACJ,OAAOE,CAAC,GAAGH,KAAK,EAAE,GAAG,KAAK;QAC9B;QACA;QACA;QACA;UACI,OAAOC,CAAC,KAAKE,CAAC,KAAKF,CAAC,KAAKG,SAAS,GAAG,IAAI,GAAGJ,KAAK,EAAE,CAAC;MAAC;IAEjE,CAAC;IACD,OAAOA,KAAK,EAAE;EAClB;EACA;AACJ;AACA;EACIzG,OAAO,CAAC8G,IAAI,EAAExF,MAAM,EAAE;IAClB,MAAMwB,OAAO,GAAGf,SAAS,CAAC,IAAI,CAACe,OAAO,IAAI,CAAC,CAAC,EAAEgE,IAAI,CAAC;IACnD,MAAMC,QAAQ,GAAGjE,OAAO,CAACiE,QAAQ,IAAI,IAAI;IACzC,MAAMjG,QAAQ,GAAGgC,OAAO,CAAChC,QAAQ,IAAI,WAAW;IAChD,IAAIgC,OAAO,CAACkE,GAAG,EAAE;MACb,IAAI,CAACC,IAAI,GAAGnE,OAAO,CAACkE,GAAG;IAC3B,CAAC,MACI;MACD,IAAI,CAACC,IAAI,GAAI,GAAEF,QAAS,MAAKjG,QAAS,EAAC;MACvC,IAAI,CAACmG,IAAI,IAAInE,OAAO,CAAC/B,IAAI,GAAI,IAAG+B,OAAO,CAAC/B,IAAK,EAAC,GAAG,EAAE;MACnD,IAAI,CAACkG,IAAI,IAAInE,OAAO,CAAC9B,IAAI,GAAI,GAAE8B,OAAO,CAAC9B,IAAK,EAAC,GAAG,EAAE;IACtD;IACA,IAAI,CAACgC,KAAK,CAACuB,IAAI,CAAC5D,mBAAmB,CAACgE,UAAU,CAAC;IAC/C,MAAMuC,aAAa,GAAGnF,SAAS,CAAC;MAC5B0D,QAAQ,EAAE,IAAI,CAACtC,SAAS;MACxBgE,eAAe,EAAE,IAAI,CAAC7D,gBAAgB;MACtC8D,cAAc,EAAE,IAAI,CAAC/D;IACzB,CAAC,EAAEP,OAAO,CAAC;IACX,IAAI,IAAI,CAACxB,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAAC+F,GAAG,CAAC,IAAI,CAAC;IACzB;IACA,IAAI,CAAC/F,MAAM,EAAE;MACT,IAAI,CAACA,MAAM,GAAGtB,OAAO,CAAC,IAAI,CAACiH,IAAI,EAAEC,aAAa,CAAC;IACnD,CAAC,MACI;MACD,IAAI,CAAC5F,MAAM,GAAGA,MAAM;IACxB;IACA,IAAI,CAAC6B,SAAS,GAAG+D,aAAa,CAACzB,QAAQ;IACvC,IAAI,CAACnE,MAAM,CAACgG,EAAE,CAAC,SAAS,EAAE,IAAI,CAACrD,gBAAgB,CAAC;IAChD,IAAI,CAAC3C,MAAM,CAACgG,EAAE,CAAC,WAAW,EAAE,IAAI,CAAC5C,kBAAkB,CAAC;IACpD,IAAI,CAACpD,MAAM,CAACgG,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC1C,cAAc,CAAC;IAC5C,IAAI,CAACtD,MAAM,CAACgG,EAAE,CAAC,SAAS,EAAE,IAAI,CAACzC,gBAAgB,CAAC;IAChD,IAAI,CAACvD,MAAM,CAACgG,EAAE,CAAC,OAAO,EAAE,IAAI,CAACxC,cAAc,CAAC;IAC5C,IAAI,CAACxD,MAAM,CAACiG,MAAM,CAACD,EAAE,CAAC,OAAO,EAAE,IAAI,CAACxC,cAAc,CAAC;IACnD,IAAI,CAACxD,MAAM,CAACgG,EAAE,CAAC,KAAK,EAAE,IAAI,CAACrC,YAAY,CAAC;IACxC,IAAI,CAAC3D,MAAM,CAACgG,EAAE,CAAC,SAAS,EAAE,IAAI,CAACpC,gBAAgB,CAAC;IAChD,IAAI,CAAC5D,MAAM,CAACgG,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC/B,mBAAmB,CAAC;IACtD,IAAI,CAACjE,MAAM,CAACgG,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC9B,sBAAsB,CAAC;EAChE;EACA;AACJ;AACA;AACA;EACIgC,UAAU,CAACC,KAAK,GAAG,IAAI,EAAE;IACrB,IAAI,CAAC,IAAI,CAACnG,MAAM,EAAE;MACd,MAAM,IAAIoG,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,IAAI,CAACpG,MAAM,CAAC+F,GAAG,CAACI,KAAK,CAAC;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,eAAe,CAACtD,YAAY,EAAEyC,IAAI,GAAG;IAAEc,GAAG,EAAE;EAAE,CAAC,EAAE;IAC7C,OAAO,IAAI,CAACC,eAAe,CAACxD,YAAY,EAAE,MAAM9D,aAAa,CAAC,CAAC,CAAC,EAAEuG,IAAI,CAAC;EAC3E;EACA;AACJ;AACA;AACA;AACA;AACA;EACIgB,OAAO,CAACzD,YAAY,EAAEyC,IAAI,GAAG;IAAEc,GAAG,EAAE;EAAE,CAAC,EAAE;IACrC,OAAO,IAAI,CAACC,eAAe,CAACxD,YAAY,EAAE,MAAM7D,OAAO,EAAE,EAAEsG,IAAI,CAAC;EACpE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,eAAe,CAACxD,YAAY,EAAE0D,SAAS,EAAEjB,IAAI,EAAE;IAC3C,IAAI,CAAC,IAAI,CAACxF,MAAM,EAAE;MACd,MAAM,IAAIoG,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,IAAI,CAAC,IAAI,CAAC3E,WAAW,CAACsB,YAAY,CAAC,EAAE;MACjC,MAAM2D,QAAQ,GAAG,IAAI9H,OAAO,EAAE;MAC9B,IAAI,CAAC6C,WAAW,CAACsB,YAAY,CAAC,GAAGlE,KAAK;MACtC;MACA;MACA,MAAM;QACF,MAAM8H,YAAY,GAAG,IAAI7H,YAAY,EAAE;QACvC,IAAI,CAACkB,MAAM,CAACgD,SAAS,CAACD,YAAY,EAAEyC,IAAI,EAAE,CAACoB,GAAG,EAAEC,OAAO,KAAK;UACxD,IAAIA,OAAO,EAAE;YAAE;YACXA,OAAO,CAAC/D,OAAO,CAAEgE,QAAQ,IAAK;cAC1B,IAAIA,QAAQ,CAACR,GAAG,KAAK,GAAG,EAAE;gBACtB,OAAO,IAAI,CAAC7E,WAAW,CAACqF,QAAQ,CAACjD,KAAK,CAAC;gBACvC,IAAI,CAAC7D,MAAM,CAAC+G,WAAW,CAACD,QAAQ,CAACjD,KAAK,CAAC;gBACvC6C,QAAQ,CAAChD,KAAK,CAAE,qBAAoBoD,QAAQ,CAACjD,KAAM,aAAY,CAAC;cACpE;cACA,IAAI,CAACrB,SAAS,CAACW,IAAI,CAAC;gBAAEhE,MAAM,EAAE4D,YAAY;gBAAE8D,OAAO,EAAEC,QAAQ,CAACR,GAAG,KAAK;cAAI,CAAC,CAAC;YAChF,CAAC,CAAC;UACN;QACJ,CAAC,CAAC;QACFK,YAAY,CAACK,GAAG,CAAC,MAAM;UACnB,OAAO,IAAI,CAACvF,WAAW,CAACsB,YAAY,CAAC;UACrC,IAAI,CAAC/C,MAAM,CAAC+G,WAAW,CAAChE,YAAY,CAAC;QACzC,CAAC,CAAC;QACF,OAAO4D,YAAY;MACvB,CAAC;MACD;MACA;MACA;MACCA,YAAY,IAAK5H,KAAK,CAAC2H,QAAQ,EAAE,IAAI,CAAC9E,QAAQ,CAAC,CAAC,CAC5CqF,IAAI,CAAC9H,MAAM,CAAE+H,GAAG,IAAK5F,WAAW,CAACwD,kBAAkB,CAAC/B,YAAY,EAAEmE,GAAG,CAACrD,KAAK,CAAC,CAAC,EAAE4C,SAAS,EAAE,EAAErH,QAAQ,EAAE,CAAC;IAChH;IACA,OAAO,IAAI,CAACqC,WAAW,CAACsB,YAAY,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI7D,OAAO,CAAC2E,KAAK,EAAEsD,OAAO,EAAE3F,OAAO,GAAG,CAAC,CAAC,EAAE;IAClC,IAAI,CAAC,IAAI,CAACxB,MAAM,EAAE;MACd,MAAM,IAAIoG,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,OAAOpH,UAAU,CAACoI,MAAM,CAAEC,GAAG,IAAK;MAC9B,IAAI,CAACrH,MAAM,CAACd,OAAO,CAAC2E,KAAK,EAAEsD,OAAO,EAAE3F,OAAO,EAAGkC,KAAK,IAAK;QACpD,IAAIA,KAAK,EAAE;UACP2D,GAAG,CAAC3D,KAAK,CAACA,KAAK,CAAC;QACpB,CAAC,MACI;UACD2D,GAAG,CAACpE,IAAI,EAAE;UACVoE,GAAG,CAACC,QAAQ,EAAE;QAClB;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACIC,aAAa,CAAC1D,KAAK,EAAEsD,OAAO,EAAE3F,OAAO,GAAG,CAAC,CAAC,EAAE;IACxC,IAAI,CAAC,IAAI,CAACxB,MAAM,EAAE;MACd,MAAM,IAAIoG,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,IAAI,CAACpG,MAAM,CAACd,OAAO,CAAC2E,KAAK,EAAEsD,OAAO,EAAE3F,OAAO,EAAGkC,KAAK,IAAK;MACpD,IAAIA,KAAK,EAAE;QACP,MAAOA,KAAK;MAChB;IACJ,CAAC,CAAC;EACN;EACA5B,iBAAiB,GAAG;IAChB,OAAO,SAAS,GAAG0F,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;EAC/D;EAAC,YACQ,IAAI,CAACtH,IAAI;IAAA,iBAAwFiB,WAAW,EAhWrBnD,EAAE,UAgWqCwB,iBAAiB,GAhWxDxB,EAAE,UAgWmEyB,iBAAiB;EAAA,CAA6C;EAAA,aAC1N,IAAI,CAACgI,KAAK,kBAjW6EzJ,EAAE;IAAA,OAiWYmD,WAAW;IAAA,SAAXA,WAAW;IAAA,YAAc;EAAM,EAAG;AACpJ;AACA;EAAA,mDAnWoGnD,EAAE,mBAmWXmD,WAAW,EAAc,CAAC;IACzGd,IAAI,EAAEjC,UAAU;IAChBsJ,IAAI,EAAE,CAAC;MACCC,UAAU,EAAE;IAChB,CAAC;EACT,CAAC,CAAC,EAAkB,YAAY;IAAE,OAAO,CAAC;MAAEtH,IAAI,EAAE+E,SAAS;MAAEwC,UAAU,EAAE,CAAC;QAC9DvH,IAAI,EAAEhC,MAAM;QACZqJ,IAAI,EAAE,CAAClI,iBAAiB;MAC5B,CAAC;IAAE,CAAC,EAAE;MAAEa,IAAI,EAAE/B,EAAE,CAACuJ,UAAU;MAAED,UAAU,EAAE,CAAC;QACtCvH,IAAI,EAAEhC,MAAM;QACZqJ,IAAI,EAAE,CAACjI,iBAAiB;MAC5B,CAAC;IAAE,CAAC,CAAC;EAAE,CAAC;AAAA;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAASN,oBAAoB,EAAEM,iBAAiB,EAAEP,mBAAmB,EAAEQ,UAAU,EAAEyB,WAAW,EAAE3B,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}